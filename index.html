<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Block Maze — Full Single-File Game</title>
<style>
  html,body { height:100%; margin:0; background:#050508; color:#fff; font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; overflow:hidden; }
  #overlay {
    position:absolute; left:10px; top:10px; z-index:10;
    background: rgba(0,0,0,0.35); padding:8px 10px; border-radius:8px;
    backdrop-filter: blur(4px);
  }
  #hud { position:absolute; right:10px; top:10px; z-index:10; text-align:right; background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:8px; }
  #message { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:12; padding:14px 22px; border-radius:12px; background:rgba(0,0,0,0.6); display:none; }
  #canvas-container { width:100%; height:100%; }
  #fps { font-size:12px; color:#bfefff; }
  #controls { font-size:13px; }
  a { color:#9fd; }
  .small { font-size:12px; color:#ddd; opacity:0.9; margin-top:6px; }
</style>
</head>
<body>
<div id="overlay">
  <div style="font-weight:700; font-size:16px;">Block Maze — Sword Demo</div>
  <div id="controls" class="small">W A S D — Move &nbsp;•&nbsp; Mouse — Look &nbsp;•&nbsp; Click — Swing</div>
  <div class="small" style="margin-top:8px;">Tip: click canvas to lock pointer. Press Esc to release.</div>
</div>
<div id="hud">
  <div id="health">Health: 100</div>
  <div id="monsters">Monsters: 0</div>
  <div id="fps">FPS: 0</div>
</div>
<div id="message"></div>
<div id="canvas-container"></div>

<!-- Three.js (module-free build for single-file simplicity) -->
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
/* =========================================================
   Full Single-File Game (fixed: yaw/pitch declared)
   ========================================================= */

(() => {
  // Basic config
  const CELL = 2.0;             // cell size (world units)
  const MAZE_W = 21;            // odd numbers work well
  const MAZE_H = 21;
  const PLAYER_HEIGHT = 1.6;
  const PLAYER_SPEED = 2.2;     // units per second
  const MONSTER_COUNT = 8;
  const MONSTER_SPEED = 0.9;
  const SWING_COOLDOWN = 0.6;   // seconds
  const TRAIL_LENGTH = 12;      // sword trail points

  // DOM
  const container = document.getElementById('canvas-container');
  const hudHealth = document.getElementById('health');
  const hudMonsters = document.getElementById('monsters');
  const hudFPS = document.getElementById('fps');
  const messageBox = document.getElementById('message');

  // IMPORTANT FIX: declare yaw and pitch here so all code can access them.
  // The ReferenceError you saw was because these were referenced before being declared.
  let yaw = 0, pitch = 0;

  // Three essentials
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0c1116);
  scene.fog = new THREE.FogExp2(0x0c1116, 0.035);

  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 500);
  camera.position.set(CELL, PLAYER_HEIGHT, CELL);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  // Resize
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Clock
  const clock = new THREE.Clock();

  // Texture loader
  const tloader = new THREE.TextureLoader();
  const floorTex = tloader.load('https://i.imgur.com/yY6tjqm.jpeg');
  floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
  floorTex.repeat.set(20,20);
  const wallTex = tloader.load('https://i.imgur.com/Jd2NPFf.jpeg');
  wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
  wallTex.repeat.set(1,1);
  const monsterTex = tloader.load('https://i.imgur.com/8d5VGwN.jpeg');

  // Lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.6);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xfff7ec, 0.9);
  sun.position.set(30, 50, 40);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048,2048);
  sun.shadow.camera.left = -50;
  sun.shadow.camera.right = 50;
  sun.shadow.camera.top = 50;
  sun.shadow.camera.bottom = -50;
  scene.add(sun);

  // Floor
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(CELL*MAZE_W*1.5, CELL*MAZE_H*1.5), new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.9 }));
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Variables to store world objects
  let walls = [];    // meshes for walls (for collision)
  let monsters = []; // Monster instances
  const particles = []; // particle containers (used by restart and updateParticles)

  // Helper: Vector2 equality tolerance
  function vec2Equal(a,b){ return Math.abs(a.x-b.x)<0.001 && Math.abs(a.y-b.y)<0.001; }

  /* ----------------------
     Maze generation (grid of cells, recursive backtracker)
     ---------------------- */
  class Maze {
    constructor(w, h) {
      this.w = (w % 2 === 0) ? w+1 : w;
      this.h = (h % 2 === 0) ? h+1 : h;
      this.grid = [];
      for(let z=0; z<this.h; z++){
        this.grid[z] = [];
        for(let x=0; x<this.w; x++){
          this.grid[z][x] = '#';
        }
      }
    }

    generate() {
      const w = this.w, h = this.h;
      const stack = [];
      const startX = 1, startZ = 1;
      this.grid[startZ][startX] = '.';
      stack.push({x:startX,z:startZ});

      const dirs = [
        {x:0,z:-2}, {x:2,z:0}, {x:0,z:2}, {x:-2,z:0}
      ];

      while(stack.length){
        const cur = stack[stack.length-1];
        const neighbors = [];
        for(const d of dirs){
          const nx = cur.x + d.x;
          const nz = cur.z + d.z;
          if(nx>0 && nz>0 && nx<w-1 && nz<h-1 && this.grid[nz][nx] === '#'){
            neighbors.push({x:nx,z:nz,dir:d});
          }
        }
        if(neighbors.length === 0) {
          stack.pop();
        } else {
          const pick = neighbors[Math.floor(Math.random()*neighbors.length)];
          const betweenX = cur.x + pick.dir.x/2;
          const betweenZ = cur.z + pick.dir.z/2;
          this.grid[betweenZ][betweenX] = '.';
          this.grid[pick.z][pick.x] = '.';
          stack.push({x:pick.x,z:pick.z});
        }
      }

      this.grid[1][0] = '.';
      this.grid[this.h-2][this.w-1] = '.';
    }

    buildMeshes() {
      walls.forEach(w => scene.remove(w.mesh));
      walls = [];

      const wallGeom = new THREE.BoxGeometry(CELL, CELL*1.1, CELL);
      const wallMat = new THREE.MeshStandardMaterial({ map: wallTex, metalness: 0.02, roughness: 0.9 });

      const offsetX = - (this.w * CELL)/2 + CELL/2;
      const offsetZ = - (this.h * CELL)/2 + CELL/2;

      for(let z=0; z<this.h; z++){
        for(let x=0; x<this.w; x++){
          if(this.grid[z][x] === '#'){
            const mesh = new THREE.Mesh(wallGeom, wallMat);
            mesh.position.set(offsetX + x*CELL, CELL*0.55, offsetZ + z*CELL);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            walls.push({mesh, x, z});
          }
        }
      }
      return {offsetX, offsetZ};
    }
  }

  // Create procedural maze
  const maze = new Maze(MAZE_W, MAZE_H);
  maze.generate();
  const offsets = maze.buildMeshes();

  /* ----------------------
     Player class (handles movement, collision, health)
     ---------------------- */
  class Player {
    constructor(camera) {
      this.camera = camera;
      this.pos = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
      this.yaw = 0;
      this.pitch = 0;
      this.health = 100;
      this.speed = PLAYER_SPEED;
      this.radius = 0.35; // collision radius
      this.walkCool = 0;
      this.canMove = true;
      this.swingTimer = 0;
      this.shake = {intensity:0, duration:0};
    }

    applyShake(dt){
      if(this.shake.duration > 0){
        this.shake.duration -= dt;
        const s = this.shake.intensity * (this.shake.duration / 0.25);
        camera.position.x += (Math.random()*2-1) * s;
        camera.position.y += (Math.random()*2-1) * s * 0.5;
        camera.position.z += (Math.random()*2-1) * s;
      }
    }

    setPosition(x,z){
      this.pos.x = x; this.pos.z = z;
      this.camera.position.x = x;
      this.camera.position.z = z;
      this.camera.position.y = PLAYER_HEIGHT;
    }

    update(dt, input) {
      if(!this.canMove) return;
      // compute direction vector in world coords using global yaw
      const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
      const right = new THREE.Vector3(Math.sin(yaw + Math.PI/2), 0, Math.cos(yaw + Math.PI/2));
      let move = new THREE.Vector3();

      if(input.forward) move.addScaledVector(forward, 1);
      if(input.back) move.addScaledVector(forward, -1);
      if(input.left) move.addScaledVector(right, -1);
      if(input.right) move.addScaledVector(right, 1);

      if(move.length() > 0.001){
        move.normalize();
        const wanted = this.pos.clone().addScaledVector(move, this.speed * dt);
        if(!checkCollisionCircle(wanted.x, wanted.z, this.radius)) {
          this.setPosition(wanted.x, wanted.z);
          this.walkCool += dt;
          if(this.walkCool > 0.3) {
            this.walkCool = 0;
            playFootstep();
          }
        }
      }

      if(this.swingTimer > 0) this.swingTimer = Math.max(0, this.swingTimer - dt);
      this.applyShake(dt);
    }

    damage(amount){
      this.health = Math.max(0, this.health - amount);
      hudHealth.innerText = `Health: ${this.health}`;
      this.shake.intensity = 0.12;
      this.shake.duration = 0.25;
      if(this.health <= 0){
        showMessage("You died! Press R to restart.");
        this.canMove = false;
      }
    }
  }

  /* ----------------------
     Sword class: swing animation, trail, hit detection
     ---------------------- */
  class Sword {
    constructor(player) {
      this.player = player;
      const bladeGeo = new THREE.BoxGeometry(0.08, 1.0, 0.12);
      const bladeMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness:0.8, roughness:0.2 });
      this.blade = new THREE.Mesh(bladeGeo, bladeMat);
      this.blade.castShadow = true;
      this.blade.position.set(0.4, -0.6, -1.0);
      this.blade.rotation.x = -0.25;

      const handleGeo = new THREE.BoxGeometry(0.12, 0.25, 0.12);
      const handleMat = new THREE.MeshStandardMaterial({ color: 0x553300, roughness:0.8 });
      this.handle = new THREE.Mesh(handleGeo, handleMat);
      this.handle.position.set(0.4, -1.05, -1.0);

      this.group = new THREE.Group();
      this.group.add(this.blade);
      this.group.add(this.handle);

      camera.add(this.group);
      this.group.position.set(0,0,0);
      this.swinging = false;
      this.timer = 0;
      this.cooldown = 0;
      this.trailPositions = [];
      this.trailGeo = new THREE.BufferGeometry();
      const pts = new Float32Array(TRAIL_LENGTH * 3);
      this.trailGeo.setAttribute('position', new THREE.BufferAttribute(pts, 3));
      const trailMat = new THREE.LineBasicMaterial({ color:0xffd080, transparent:true, opacity:0.9 });
      this.trail = new THREE.Line(this.trailGeo, trailMat);
      scene.add(this.trail);
      this._didHit = false;
    }

    update(dt) {
      if(this.cooldown > 0) this.cooldown = Math.max(0, this.cooldown - dt);

      if(this.swinging) {
        this.timer += dt * 6;
        const progress = this.timer;
        const angle = Math.sin(progress) * Math.PI * 0.7;
        this.group.rotation.set(angle - 0.7, 0.0, 0.0);

        const worldPos = new THREE.Vector3();
        this.blade.getWorldPosition(worldPos);
        this.trailPositions.unshift(worldPos.clone());
        if(this.trailPositions.length > TRAIL_LENGTH) this.trailPositions.pop();
        this.updateTrailGeometry();

        if(progress > Math.PI * 0.28 && progress < Math.PI * 0.55 && !this._didHit) {
          this._didHit = true;
          this.tryHitMonsters(worldPos);
        }

        if(this.timer > Math.PI) {
          this.swinging = false;
          this._didHit = false;
          this.timer = 0;
          this.cooldown = SWING_COOLDOWN;
        }
      } else {
        this.group.rotation.x = -0.3 + Math.sin(performance.now() * 0.002) * 0.02;
        if(this.trailPositions.length > 0) {
          this.trailPositions.shift();
          this.updateTrailGeometry();
        }
      }
    }

    startSwing() {
      if(this.cooldown > 0) return false;
      this.swinging = true;
      this.timer = 0.01;
      this._didHit = false;
      playSwing();
      return true;
    }

    updateTrailGeometry(){
      const pts = this.trailGeo.attributes.position.array;
      for(let i=0;i<TRAIL_LENGTH;i++){
        const p = this.trailPositions[i];
        const idx = i*3;
        if(p){
          pts[idx] = p.x; pts[idx+1] = p.y; pts[idx+2] = p.z;
        } else {
          pts[idx] = pts[idx+1] = pts[idx+2] = 0;
        }
      }
      this.trailGeo.attributes.position.needsUpdate = true;
    }

    tryHitMonsters(worldPos) {
      const hitRadius = 1.6;
      const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();
      for(let i = monsters.length - 1; i >=0; i--){
        const mon = monsters[i];
        const mpos = mon.mesh.position;
        const toMonster = mpos.clone().sub(camera.position);
        const dist = toMonster.length();
        if(dist <= hitRadius) {
          toMonster.y = 0;
          toMonster.normalize();
          const dot = forward.dot(toMonster);
          if(dot > 0.3) {
            mon.hit(1 + Math.floor(Math.random()*3));
            playHit();
            spawnHitParticles(mpos.x, mpos.y + 0.5, mpos.z);
            const kb = toMonster.clone().multiplyScalar(-0.8);
            mon.applyKnockback(kb);
            if(mon.hp <= 0){
              scene.remove(mon.mesh);
              monsters.splice(i,1);
              hudMonsters.innerText = `Monsters: ${monsters.length}`;
            }
          }
        }
      }
    }
  }

  /* ----------------------
     Monster class
     ---------------------- */
  class Monster {
    constructor(x,z) {
      const geo = new THREE.BoxGeometry(CELL*0.4, CELL*0.9, CELL*0.4);
      const mat = new THREE.MeshStandardMaterial({ map: monsterTex, color: 0xff6666, roughness: 0.8, metalness:0.1 });
      this.mesh = new THREE.Mesh(geo, mat);
      this.mesh.castShadow = true;
      this.mesh.position.set(x, 0.45, z);
      scene.add(this.mesh);

      const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);
      const eyeMat = new THREE.MeshBasicMaterial({ color:0xff9933 });
      this.eye = new THREE.Mesh(eyeGeo, eyeMat);
      this.eye.position.set(0, 0.45, 0.26);
      this.mesh.add(this.eye);

      this.hp = 3 + Math.floor(Math.random()*3);
      this.speed = MONSTER_SPEED * (0.8 + Math.random()*0.6);
      this.knockback = new THREE.Vector3();
      this.knockTimer = 0;
    }

    update(dt) {
      this.mesh.position.y = 0.45 + Math.sin(performance.now() * 0.002 + (this.mesh.position.x + this.mesh.position.z)) * 0.06;
      const glow = 0.5 + Math.abs(Math.sin(performance.now()*0.003 + this.mesh.position.x)) * 0.6;
      this.eye.material.color.setScalar(1.0);
      this.eye.material.needsUpdate = true;
      this.eye.scale.set(1,1,1).multiplyScalar(1 + (glow-0.5)*0.15);

      const toPlayer = camera.position.clone().sub(this.mesh.position);
      toPlayer.y = 0;
      const dist = toPlayer.length();
      if(this.knockTimer > 0){
        this.mesh.position.addScaledVector(this.knockback, dt);
        this.knockTimer -= dt;
        if(this.knockTimer <= 0) this.knockback.set(0,0,0);
        return;
      }
      if(dist > 1.6) {
        toPlayer.normalize();
        const wanted = this.mesh.position.clone().addScaledVector(toPlayer, this.speed * dt);
        if(!checkCollisionCircle(wanted.x, wanted.z, 0.35)){
          this.mesh.position.copy(wanted);
        }
      } else {
        if(Math.random() < dt * 0.25) {
          player.damage(6 + Math.floor(Math.random()*5));
        }
      }
    }

    hit(dmg) {
      this.hp -= dmg;
      this.mesh.material.color.setHex(0xff4444);
      setTimeout(()=> {
        this.mesh.material.color.setHex(0xff6666);
      }, 120);
    }

    applyKnockback(vec) {
      this.knockback.copy(vec);
      this.knockTimer = 0.15 + Math.random()*0.08;
    }
  }

  /* ----------------------
     Effects: particle system for hits
     ---------------------- */
  function spawnHitParticles(x,y,z) {
    const particleCount = 18 + Math.floor(Math.random()*12);
    const geom = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const velocities = [];
    for(let i=0;i<particleCount;i++){
      positions[i*3] = x;
      positions[i*3+1] = y;
      positions[i*3+2] = z;
      const v = new THREE.Vector3((Math.random()*2-1)*1.8, Math.random()*1.6, (Math.random()*2-1)*1.8);
      velocities.push(v);
    }
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const material = new THREE.PointsMaterial({ size: 0.08, color: 0xffd0a6, transparent:true });
    const pts = new THREE.Points(geom, material);
    pts._velocities = velocities;
    pts._life = 0.8 + Math.random()*0.5;
    scene.add(pts);
    particles.push(pts);
  }

  function updateParticles(dt) {
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p._life -= dt;
      const pos = p.geometry.attributes.position.array;
      for(let j=0;j<pos.length/3;j++){
        pos[j*3] += p._velocities[j].x * dt;
        pos[j*3+1] += p._velocities[j].y * dt;
        pos[j*3+2] += p._velocities[j].z * dt;
        p._velocities[j].y -= 3.5 * dt;
        p._velocities[j].multiplyScalar(0.995);
      }
      p.geometry.attributes.position.needsUpdate = true;
      p.material.opacity = Math.max(0, p._life / 1.0);
      if(p._life <= 0) {
        scene.remove(p);
        particles.splice(i,1);
      }
    }
  }

  /* ----------------------
     Collision helpers (circle vs grid wall)
     ---------------------- */
  function checkCollisionCircle(wx, wz, radius) {
    for(const w of walls){
      const mx = w.mesh.position.x;
      const mz = w.mesh.position.z;
      const dx = wx - mx;
      const dz = wz - mz;
      const half = CELL*0.5 * 0.9;
      const closestX = Math.max(-half, Math.min(half, dx));
      const closestZ = Math.max(-half, Math.min(half, dz));
      const ox = dx - closestX;
      const oz = dz - closestZ;
      const dist2 = ox*ox + oz*oz;
      if(dist2 < (radius*radius)) return true;
    }
    return false;
  }

  /* ----------------------
     Input & Pointer Lock
     ---------------------- */
  const input = { forward:false, back:false, left:false, right:false };

  window.addEventListener('keydown', (e) => {
    if(e.code === 'KeyW') input.forward = true;
    if(e.code === 'KeyS') input.back = true;
    if(e.code === 'KeyA') input.left = true;
    if(e.code === 'KeyD') input.right = true;
    if(e.code === 'KeyR') restart();
  });
  window.addEventListener('keyup', (e) => {
    if(e.code === 'KeyW') input.forward = false;
    if(e.code === 'KeyS') input.back = false;
    if(e.code === 'KeyA') input.left = false;
    if(e.code === 'KeyD') input.right = false;
  });

  // Mouse look via pointer lock
  let pointerLocked = false;
  renderer.domElement.style.cursor = 'pointer';
  renderer.domElement.addEventListener('click', () => {
    renderer.domElement.requestPointerLock();
  });
  document.addEventListener('pointerlockchange', () => {
    pointerLocked = document.pointerLockElement === renderer.domElement;
    renderer.domElement.style.cursor = pointerLocked ? 'none' : 'pointer';
  });

  // track yaw/pitch global variables
  window.addEventListener('mousemove', (e) => {
    if(!pointerLocked) return;
    const sensitivity = 0.0024;
    yaw -= e.movementX * sensitivity;
    pitch -= e.movementY * sensitivity;
    pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, pitch));
    camera.rotation.set(pitch, yaw, 0);
  });

  // click to swing
  window.addEventListener('mousedown', (e) => {
    if(!pointerLocked) return;
    if(e.button === 0) {
      const started = sword.startSwing();
      if(started){
        player.shake.intensity = 0.02;
        player.shake.duration = 0.08;
      }
    }
  });

  // instantiate player & sword
  const player = new Player(camera);
  player.setPosition(offsets.offsetX + CELL, offsets.offsetZ + CELL);

  const sword = new Sword(player);

  // Spawn monsters at free cells
  function pickFreeCell() {
    while(true){
      const x = Math.floor(Math.random() * (maze.w - 2)) + 1;
      const z = Math.floor(Math.random() * (maze.h - 2)) + 1;
      if(maze.grid[z][x] === '.') {
        const wx = offsets.offsetX + x*CELL;
        const wz = offsets.offsetZ + z*CELL;
        if(Math.hypot(wx - player.pos.x, wz - player.pos.z) > CELL * 3) {
          return {x:wx, z:wz};
        }
      }
    }
  }

  for(let i=0;i<MONSTER_COUNT;i++){
    const pos = pickFreeCell();
    const m = new Monster(pos.x, pos.z);
    monsters.push(m);
  }
  hudMonsters.innerText = `Monsters: ${monsters.length}`;

  // simple fps counter (declared before update uses it)
  let frames = 0, accum = 0;

  /* ----------------------
     Sound (WebAudio)
     ---------------------- */
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function playTone(freq, time, type='sine', gain=0.05) {
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    g.gain.value = gain;
    osc.connect(g);
    g.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + time);
    g.gain.setValueAtTime(g.gain.value, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
  }
  function playFootstep(){ playTone(120 + Math.random()*30, 0.12, 'sine', 0.03); }
  function playSwing(){ playTone(650 + Math.random()*120, 0.08, 'triangle', 0.08); playTone(320, 0.12, 'sine', 0.02); }
  function playHit(){ playTone(240, 0.06, 'sawtooth', 0.12); playTone(980, 0.12, 'square', 0.04); }

  /* ----------------------
     HUD & messages
     ---------------------- */
  function showMessage(text, t=4000) {
    messageBox.innerText = text;
    messageBox.style.display = 'block';
    if(t>0) setTimeout(()=> messageBox.style.display='none', t);
  }

  // restart
  function restart(){
    monsters.forEach(m => scene.remove(m.mesh));
    monsters.length = 0;
    particles.forEach(p => scene.remove(p));
    particles.length = 0;
    maze.generate();
    const newOffsets = maze.buildMeshes();
    player.setPosition(newOffsets.offsetX + CELL, newOffsets.offsetZ + CELL);
    for(let i=0;i<MONSTER_COUNT;i++){
      const pos = pickFreeCell();
      const m = new Monster(pos.x, pos.z);
      monsters.push(m);
    }
    hudMonsters.innerText = `Monsters: ${monsters.length}`;
    player.health = 100;
    hudHealth.innerText = `Health: ${player.health}`;
    messageBox.style.display = 'none';
    player.canMove = true;
  }

  /* ----------------------
     Main loop
     ---------------------- */
  function update(dt) {
    player.update(dt, input);
    sword.update(dt);
    for(const m of monsters) m.update(dt);
    updateParticles(dt);

    frames++;
    accum += dt;
    if(accum > 0.5){
      hudFPS.innerText = `FPS: ${Math.round(frames/accum)}`;
      frames = 0; accum = 0;
    }
  }

  function render() {
    renderer.render(scene, camera);
  }

  // animation frame
  function animate() {
    const dt = Math.min(0.05, clock.getDelta());
    update(dt);
    render();
    requestAnimationFrame(animate);
  }

  // Start
  animate();
  showMessage('Click the screen to lock pointer and play', 3500);

  // Note about favicon 404:
  // The browser automatically tries to fetch /favicon.ico. If your server doesn't provide one you'll see a 404 in DevTools — it's harmless.

})();
</script>
</body>
</html>
