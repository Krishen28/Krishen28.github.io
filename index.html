<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Maze Sword Game</title>
<style>
  html,body {margin:0;overflow:hidden;height:100%;background:#000;color:white;font-family:sans-serif;}
  #info{position:absolute;top:10px;width:100%;text-align:center;z-index:1;}
  #healthbar {
    position:absolute;bottom:10px;left:50%;transform:translateX(-50%);
    width:60%;height:20px;background:#333;border:2px solid #fff;
  }
  #health {
    height:100%;background:#0f0;width:100%;
    transition:width 0.2s linear;
  }
  #deathMessage {
    position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
    font-size:48px;color:red;font-weight:bold;display:none;z-index:10;
    text-shadow:2px 2px 8px black;
  }
</style>
</head>
<body>
<div id="info">W A S D = Move | Mouse = Look | Click = Swing Sword</div>
<div id="healthbar"><div id="health"></div></div>
<div id="deathMessage">YOU DIED</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
let scene,camera,renderer;
const keys={},monsters=[],walls=[];
let yaw=0,pitch=0;
let sword,swordSwing=0,isSwinging=false;
let playerHealth=1;
let spawnTimer=0;
let isDead=false;
let monsterDifficulty=1;

init();
animate();

function init(){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x222244);

  camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
  camera.position.set(0,2,8);

  const sun=new THREE.DirectionalLight(0xffffff,1);
  sun.position.set(5,10,5);
  scene.add(sun);
  scene.add(new THREE.AmbientLight(0xffffff,0.5));

  // floor
  const floor=new THREE.Mesh(
    new THREE.PlaneGeometry(200,200),
    new THREE.MeshPhongMaterial({color:0x446644})
  );
  floor.rotation.x=-Math.PI/2;
  scene.add(floor);

  // MAZE GENERATION (simple grid maze using recursive backtracking)
  generateMaze(10, 10, 8);

  // sword
  const sGeo=new THREE.BoxGeometry(0.2,1.5,0.2);
  const sMat=new THREE.MeshPhongMaterial({color:0xccaa00});
  sword=new THREE.Mesh(sGeo,sMat);
  sword.position.set(0.5,-0.5,-1.5);
  camera.add(sword);
  scene.add(camera);

  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth,innerHeight);
  document.body.appendChild(renderer.domElement);

  document.addEventListener("keydown",e=>keys[e.code]=true);
  document.addEventListener("keyup",e=>keys[e.code]=false);

  document.addEventListener("mousemove",e=>{
    yaw-=e.movementX*0.002;
    pitch-=e.movementY*0.002;
    pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,pitch));
    camera.rotation.set(pitch,yaw,0);
  });

  document.addEventListener("click",()=>{
    if(!isSwinging && !isDead){
      isSwinging=true;
      swordSwing=0;
    }
  });

  window.addEventListener("resize",()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });
}

function animate(){
  requestAnimationFrame(animate);
  if(!isDead){
    movePlayer();
    moveMonsters();
    updateSword();
    updateSpawner();
  }
  renderer.render(scene,camera);
}

// -------------------- MAZE GENERATION --------------------
function generateMaze(rows, cols, cellSize){
  const grid = [];
  for(let z=0;z<rows;z++){
    grid[z]=[];
    for(let x=0;x<cols;x++){
      grid[z][x]={visited:false,walls:[true,true,true,true]}; // top right bottom left
    }
  }

  const stack=[];
  let cx=0,cz=0;
  grid[cz][cx].visited=true;
  stack.push({x:cx,z:cz});

  while(stack.length>0){
    const current=stack[stack.length-1];
    const {x,z}=current;
    const neighbors=[];

    const directions=[
      {dx:0,dz:-1,wall:0,opp:2}, // top
      {dx:1,dz:0,wall:1,opp:3},  // right
      {dx:0,dz:1,wall:2,opp:0},  // bottom
      {dx:-1,dz:0,wall:3,opp:1}  // left
    ];

    for(const dir of directions){
      const nx=x+dir.dx,nz=z+dir.dz;
      if(nx>=0&&nx<cols&&nz>=0&&nz<rows&&!grid[nz][nx].visited){
        neighbors.push({...dir,nx,nz});
      }
    }

    if(neighbors.length>0){
      const next=neighbors[Math.floor(Math.random()*neighbors.length)];
      grid[z][x].walls[next.wall]=false;
      grid[next.nz][next.nx].walls[next.opp]=false;
      grid[next.nz][next.nx].visited=true;
      stack.push({x:next.nx,z:next.nz});
    }else{
      stack.pop();
    }
  }

  // Build 3D walls
  const wallGeo=new THREE.BoxGeometry(cellSize,4,1);
  const wallMat=new THREE.MeshPhongMaterial({color:0x777777});
  for(let z=0;z<rows;z++){
    for(let x=0;x<cols;x++){
      const cell=grid[z][x];
      const wx=x*cellSize - (cols*cellSize)/2;
      const wz=z*cellSize - (rows*cellSize)/2;
      if(cell.walls[0]) addWall(wx,2,wz-cellSize/2,0);
      if(cell.walls[1]) addWall(wx+cellSize/2,2,wz,Math.PI/2);
      if(cell.walls[2]) addWall(wx,2,wz+cellSize/2,0);
      if(cell.walls[3]) addWall(wx-cellSize/2,2,wz,Math.PI/2);
    }
  }

  function addWall(x,y,z,rot){
    const wall=new THREE.Mesh(wallGeo,wallMat);
    wall.position.set(x,y,z);
    wall.rotation.y=rot;
    scene.add(wall);
    walls.push(wall);
  }
}

// -------------------- GAME FUNCTIONS --------------------
function movePlayer(){
  const speed=0.3;
  const dir=new THREE.Vector3();
  if(keys["KeyW"]) dir.z-=1;
  if(keys["KeyS"]) dir.z+=1;
  if(keys["KeyA"]) dir.x-=1;
  if(keys["KeyD"]) dir.x+=1;
  dir.normalize();

  const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  const right=new THREE.Vector3(Math.sin(yaw+Math.PI/2),0,Math.cos(yaw+Math.PI/2));
  const move=new THREE.Vector3();
  move.addScaledVector(forward,dir.z*speed);
  move.addScaledVector(right,dir.x*speed);

  const newPos=camera.position.clone().add(move);
  let blocked=false;

  for(const w of walls){
    const dx=newPos.x-w.position.x;
    const dz=newPos.z-w.position.z;
    const dist=Math.sqrt(dx*dx+dz*dz);
    if(dist<2){blocked=true;break;}
  }

  if(!blocked) camera.position.copy(newPos);
}

function spawnMonster(){
  const mGeo=new THREE.BoxGeometry(2,2,2);
  const mMat=new THREE.MeshPhongMaterial({color:0xff0000});
  const m=new THREE.Mesh(mGeo,mMat.clone());
  m.position.set(0,1,-50 + Math.random()*10 - 5);
  m.health=monsterDifficulty;
  m.maxHealth=monsterDifficulty;
  m.isDead=false;
  m.fade=1;
  scene.add(m);
  monsters.push(m);
}

function updateSpawner(){
  spawnTimer++;
  if(spawnTimer>180){ // every 3 seconds
    spawnTimer=0;
    spawnMonster();
  }
}

function moveMonsters(){
  const playerPos=camera.position;
  for(let i=monsters.length-1;i>=0;i--){
    const m=monsters[i];

    if(m.isDead){
      m.fade -= 0.02;
      m.material.transparent = true;
      m.material.opacity = m.fade;
      if(m.fade<=0){
        scene.remove(m);
        monsters.splice(i,1);
      }
      continue;
    }

    const toPlayer=playerPos.clone().sub(m.position);
    const dist=toPlayer.length();

    if(dist<2){
      playerHealth -= 1/160;
      updateHealthBar();
      if(playerHealth<=0 && !isDead){
        playerDies();
      }
    }

    if(dist<2 && isSwinging && swordSwing<Math.PI/3){
      m.health--;
      if(m.health>0){
        m.material.color.setHSL(0,1,m.health/m.maxHealth/2+0.2);
      }else{
        m.isDead=true;
        m.material.color.set(0x222222);
        monsterDifficulty++; // increase next monster difficulty
      }
    }

    toPlayer.y=0;
    toPlayer.normalize();
    m.position.addScaledVector(toPlayer,0.05);
  }
}

function playerDies(){
  isDead=true;
  document.getElementById("deathMessage").style.display="block";
  setTimeout(()=>{
    playerHealth=1;
    monsterDifficulty=1;
    updateHealthBar();
    document.getElementById("deathMessage").style.display="none";
    isDead=false;
    camera.position.set(0,2,8);
  },2000);
}

function updateHealthBar(){
  playerHealth=Math.max(0,Math.min(1,playerHealth));
  const healthDiv=document.getElementById("health");
  healthDiv.style.width=(playerHealth*100)+"%";
  if(playerHealth>0.5) healthDiv.style.background="#0f0";
  else if(playerHealth>0.25) healthDiv.style.background="#ff0";
  else healthDiv.style.background="#f00";
}

function updateSword(){
  if(isSwinging){
    swordSwing+=0.2;
    sword.rotation.x=Math.sin(swordSwing)*Math.PI/4;
    if(swordSwing>Math.PI){
      isSwinging=false;
      sword.rotation.x=0;
    }
  }
}
</script>
</body>
</html>
