<!DOCTYPE html>
<html>
<head>
    <title>3D Maze Game</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
        #startBtn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 25px;
            background: white;
            border-radius: 12px;
            cursor: pointer;
        }
    </style>
</head>
<body>

<button id="startBtn">Click to Start</button>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>

<script>
// ------------------------------------------------------
// BASIC SETUP
// ------------------------------------------------------
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

let renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ------------------------------------------------------
// POINTER LOCK (Roblox-style mouse control)
// ------------------------------------------------------
const startBtn = document.getElementById("startBtn");
startBtn.onclick = () => {
    document.body.requestPointerLock();
    startBtn.style.display = "none";
};

// Mouse movement
let yaw = 0;
let pitch = 0;

document.addEventListener("mousemove", (e) => {
    if (document.pointerLockElement === document.body) {
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-1.3, Math.min(1.3, pitch));
        camera.rotation.set(pitch, yaw, 0);
    }
});

// ------------------------------------------------------
// MOVEMENT VARIABLES
// ------------------------------------------------------
let keys = {};
document.addEventListener("keydown", (e) => keys[e.key] = true);
document.addEventListener("keyup", (e) => keys[e.key] = false);

let speed = 0.12;

// ------------------------------------------------------
// MAZE GENERATION
// ------------------------------------------------------
function createWall(x, z) {
    let wallGeo = new THREE.BoxGeometry(1, 3, 1);
    let wallMat = new THREE.MeshLambertMaterial({ color: 0x4444ff });
    let wall = new THREE.Mesh(wallGeo, wallMat);
    wall.position.set(x, 1.5, z);
    scene.add(wall);
    walls.push(wall);
}

let walls = [];

// Simple maze layout
const maze = [
    "####################",
    "#........#.........#",
    "#..####..#..#####..#",
    "#.............#....#",
    "#..##########.#.####",
    "#..................#",
    "####################",
];

for (let z = 0; z < maze.length; z++) {
    for (let x = 0; x < maze[z].length; x++) {
        if (maze[z][x] === "#") {
            createWall(x, -z);
        }
    }
}

// ------------------------------------------------------
// FLOOR + CEILING
// ------------------------------------------------------
let floor = new THREE.Mesh(
    new THREE.PlaneGeometry(200, 200),
    new THREE.MeshLambertMaterial({ color: 0x222222 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

let ceiling = new THREE.Mesh(
    new THREE.PlaneGeometry(200, 200),
    new THREE.MeshLambertMaterial({ color: 0x111111 })
);
ceiling.position.y = 6;
ceiling.rotation.x = Math.PI / 2;
scene.add(ceiling);

// ------------------------------------------------------
// LIGHTS
// ------------------------------------------------------
let light = new THREE.PointLight(0xffffff, 1, 100);
light.position.set(5, 5, 5);
scene.add(light);

scene.add(new THREE.AmbientLight(0x404040));

// ------------------------------------------------------
// SWORD MODEL (actually looks like a sword now)
// ------------------------------------------------------
let swordGroup = new THREE.Group();

// Blade
let blade = new THREE.Mesh(
    new THREE.BoxGeometry(0.12, 1.5, 0.2),
    new THREE.MeshLambertMaterial({ color: 0xcccccc })
);
blade.position.y = 0.8;

// Handle
let handle = new THREE.Mesh(
    new THREE.BoxGeometry(0.15, 0.4, 0.15),
    new THREE.MeshLambertMaterial({ color: 0x222222 })
);
handle.position.y = 0.2;

swordGroup.add(blade, handle);
camera.add(swordGroup);
scene.add(camera);

swordGroup.position.set(0.4, -0.4, -0.7);

// ------------------------------------------------------
// MONSTER
// ------------------------------------------------------
function createMonster(x, z) {
    let monster = new THREE.Mesh(
        new THREE.BoxGeometry(1, 2, 1),
        new THREE.MeshLambertMaterial({ color: 0xff0000 })
    );
    monster.position.set(x, 1, z);
    scene.add(monster);
    monsters.push(monster);
}
let monsters = [];
createMonster(5, -5);

// ------------------------------------------------------
// COLLISION CHECK
// ------------------------------------------------------
function collides(x, z) {
    for (let w of walls) {
        if (Math.abs(w.position.x - x) < 0.6 &&
            Math.abs(w.position.z - z) < 0.6) return true;
    }
    return false;
}

// ------------------------------------------------------
// GAME LOOP
// ------------------------------------------------------
camera.position.set(2, 1.7, -2);

function animate() {
    requestAnimationFrame(animate);

    // MOVEMENT
    let forward = new THREE.Vector3(
        -Math.sin(yaw),
        0,
        -Math.cos(yaw)
    );

    let right = new THREE.Vector3(
        Math.cos(yaw),
        0,
        -Math.sin(yaw)
    );

    let newX = camera.position.x;
    let newZ = camera.position.z;

    if (keys["w"]) {
        newX += forward.x * speed;
        newZ += forward.z * speed;
    }
    if (keys["s"]) {
        newX -= forward.x * speed;
        newZ -= forward.z * speed;
    }
    if (keys["a"]) {
        newX -= right.x * speed;
        newZ -= right.z * speed;
    }
    if (keys["d"]) {
        newX += right.x * speed;
        newZ += right.z * speed;
    }

    if (!collides(newX, newZ)) {
        camera.position.x = newX;
        camera.position.z = newZ;
    }

    // MONSTER AI
    for (let m of monsters) {
        let dx = camera.position.x - m.position.x;
        let dz = camera.position.z - m.position.z;
        let dist = Math.sqrt(dx*dx + dz*dz);

        if (dist > 0.5) {
            m.position.x += dx / dist * 0.03;
            m.position.z += dz / dist * 0.03;
        }
    }

    renderer.render(scene, camera);
}

animate();
</script>

</body>
</html>
