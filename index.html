<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Advanced Block Maze Sword Game</title>
<style>
html,body {margin:0;overflow:hidden;height:100%;background:#000;color:white;font-family:sans-serif;}
#info{position:absolute;top:10px;width:100%;text-align:center;z-index:10;font-size:16px;}
#healthBarContainer{
  position:absolute;top:40px;left:50%;transform:translateX(-50%);
  width:300px;height:20px;background:#440000;border:2px solid #222;z-index:10;
}
#healthBar{
  width:100%;height:100%;background:red;
}
#deathMessage{
  position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  font-size:48px;color:red;font-weight:bold;display:none;z-index:20;
  text-shadow:2px 2px 8px black;
}
</style>
</head>
<body>
<div id="info">W A S D = Move | Mouse = Look | Click = Swing Sword</div>
<div id="healthBarContainer"><div id="healthBar"></div></div>
<div id="deathMessage">YOU DIED</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script>
/* --------------------------
         GLOBAL VARIABLES
---------------------------*/
let scene, camera, renderer;
const keys={}, walls=[], monsters=[];
let yaw=0, pitch=0;

const WALL_SIZE = 8;
const MAZE_ROWS = 20;
const MAZE_COLS = 20;

let maxHealth = 16, health = maxHealth;
let sword, swinging=false, swingValue=0;
const speed = 0.18;

let isDead = false;
let monsterDifficulty = 1;

/* --------------------------
           INIT
---------------------------*/
init();
animate();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb); // sky

  // Camera
  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);

  // Lighting
  const sun = new THREE.DirectionalLight(0xffffff, 1);
  sun.position.set(50,100,50);
  scene.add(sun);
  scene.add(new THREE.AmbientLight(0xffffff,0.4));

  // Floor
  const floorGeo = new THREE.PlaneGeometry(3000,3000);
  const floorMat = new THREE.MeshPhongMaterial({color:0x55aa55});
  const floor = new THREE.Mesh(floorGeo,floorMat);
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  // Maze scenery walls
  generateMaze(MAZE_ROWS, MAZE_COLS, WALL_SIZE);

  // Place camera at maze start
  const startX = -(MAZE_COLS*WALL_SIZE)/2 + WALL_SIZE/2;
  const startZ = -(MAZE_ROWS*WALL_SIZE)/2 + WALL_SIZE/2 + WALL_SIZE;
  camera.position.set(startX, 2, startZ);

  // Sword
  const sGeo = new THREE.BoxGeometry(0.2,1.5,0.2);
  const sMat = new THREE.MeshPhongMaterial({color:0xccaa00});
  sword = new THREE.Mesh(sGeo,sMat);
  sword.position.set(0.5,-0.5,-1.5);
  camera.add(sword);
  scene.add(camera);

  // Renderer
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth,innerHeight);
  document.body.appendChild(renderer.domElement);

  // Input
  document.addEventListener("keydown",e=>keys[e.code]=true);
  document.addEventListener("keyup",e=>keys[e.code]=false);

  document.addEventListener("mousemove",e=>{
    yaw -= e.movementX*0.002;
    pitch -= e.movementY*0.002;
    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
    camera.rotation.set(pitch,yaw,0);
  });

  // Two-finger touchpad rotation (prevents scrolling)
  document.addEventListener("wheel",(e)=>{
    e.preventDefault();
    yaw -= e.deltaX*0.002;
    pitch -= e.deltaY*0.002;
    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
    camera.rotation.set(pitch,yaw,0);
  }, {passive:false});

  document.addEventListener("click",()=>{
    if(!swinging && !isDead){
      swinging=true; swingValue=0;
    }
  });

  window.addEventListener("resize",()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });

  // Spawn monsters continuously
  setInterval(spawnMonster,1500);
}

/* --------------------------
         MAZE GENERATION
---------------------------*/
function generateMaze(rows, cols, size){
  const wallGeo = new THREE.BoxGeometry(size,4,size);
  const wallMat = new THREE.MeshPhongMaterial({color:0x888888});

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(Math.random()<0.35){
        const x = c*size - (cols*size)/2 + size/2;
        const z = r*size - (rows*size)/2 + size/2;
        const w = new THREE.Mesh(wallGeo, wallMat.clone());
        w.position.set(x,2,z);
        scene.add(w);
        walls.push(w);
      }
    }
  }
}

/* --------------------------
       MONSTER SPAWN
---------------------------*/
function spawnMonster(){
  const mGeo = new THREE.BoxGeometry(2,2,2);
  const mMat = new THREE.MeshPhongMaterial({color:0xff0000});
  const m = new THREE.Mesh(mGeo,mMat.clone());
  m.health = monsterDifficulty;
  m.maxHealth = monsterDifficulty;
  m.isDead = false;
  m.fade = 1;

  const spawnZ = (MAZE_ROWS*WALL_SIZE)/2 - WALL_SIZE;
  const spawnX = -(MAZE_COLS*WALL_SIZE)/2 + WALL_SIZE/2 + (Math.random()*WALL_SIZE - WALL_SIZE/2);
  m.position.set(spawnX,1,spawnZ);
  scene.add(m);
  monsters.push(m);
}

/* --------------------------
        GAME LOOP
---------------------------*/
function animate(){
  requestAnimationFrame(animate);
  if(!isDead){
    movePlayer();
    updateSword();
    moveMonsters();
  }
  renderer.render(scene,camera);
}

/* --------------------------
        PLAYER MOVEMENT
---------------------------*/
function movePlayer(){
  const move = new THREE.Vector3();
  if(keys["KeyW"]) move.z -= 1;
  if(keys["KeyS"]) move.z += 1;
  if(keys["KeyA"]) move.x -= 1;
  if(keys["KeyD"]) move.x += 1;
  move.normalize();

  const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  const right = new THREE.Vector3(Math.sin(yaw+Math.PI/2),0,Math.cos(yaw+Math.PI/2));

  const vel = new THREE.Vector3();
  vel.addScaledVector(forward, move.z*speed);
  vel.addScaledVector(right, move.x*speed);

  const newPos = camera.position.clone().add(vel);

  const radius = 1.0;
  let collide=false;
  for(const w of walls){
    const dx=Math.abs(newPos.x - w.position.x);
    const dz=Math.abs(newPos.z - w.position.z);
    if(dx < WALL_SIZE/2 + radius && dz < WALL_SIZE/2 + radius){ collide=true; break; }
  }

  if(!collide) camera.position.copy(newPos);
}

/* --------------------------
          SWORD
---------------------------*/
function updateSword(){
  if(swinging){
    swingValue += 0.2;
    sword.rotation.x = Math.sin(swingValue)*Math.PI/4;
    if(swingValue>Math.PI){
      swinging=false;
      sword.rotation.x=0;
    }
  }
}

/* --------------------------
        MONSTER AI
---------------------------*/
function moveMonsters(){
  const playerPos = camera.position;
  for(let i=monsters.length-1;i>=0;i--){
    const m=monsters[i];

    if(m.isDead){
      m.fade -=0.02;
      m.material.transparent=true;
      m.material.opacity = m.fade;
      if(m.fade<=0){
        scene.remove(m);
        monsters.splice(i,1);
      }
      continue;
    }

    const toPlayer = playerPos.clone().sub(m.position);
    const dist = toPlayer.length();

    if(dist < 1.5){
      damagePlayer(1);
    }

    toPlayer.y=0;
    toPlayer.normalize();
    m.position.addScaledVector(toPlayer,0.05);

    if(swinging && dist < 2){
      m.health--;
      m.material.color.setHSL(0,1,m.health/m.maxHealth/2+0.2);
      if(m.health<=0){
        m.isDead=true;
        m.material.color.set(0x222222);
        monsterDifficulty++;
      }
    }
  }
}

/* --------------------------
        HEALTH SYSTEM
---------------------------*/
function damagePlayer(amount){
  health -= amount;
  health=Math.max(0,health);
  const bar = document.getElementById("healthBar");
  bar.style.width = (health/maxHealth*100) + "%";
  if(health>maxHealth/2) bar.style.background="#0f0";
  else if(health>maxHealth/4) bar.style.background="#ff0";
  else bar.style.background="#f00";

  if(health<=0 && !isDead){
    isDead=true;
    document.getElementById("deathMessage").style.display="block";
    setTimeout(()=>{
      health = maxHealth;
      monsterDifficulty = 1;
      updateHealthBar();
      camera.position.set(-(MAZE_COLS*WALL_SIZE)/2 + WALL_SIZE/2, 2, -(MAZE_ROWS*WALL_SIZE)/2 + WALL_SIZE/2 + WALL_SIZE);
      document.getElementById("deathMessage").style.display="none";
      isDead=false;
    },2000);
  }
}

function updateHealthBar(){
  const bar = document.getElementById("healthBar");
  bar.style.width = (health/maxHealth*100) + "%";
}
</script>
</body>
</html>
