<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Block Maze Sword Game</title>
<style>
  html,body {margin:0;overflow:hidden;height:100%;background:#000;color:white;font-family:sans-serif;}
  #info{position:absolute;top:10px;width:100%;text-align:center;z-index:1;}
  #healthbar {
    position:absolute;bottom:10px;left:50%;transform:translateX(-50%);
    width:60%;height:20px;background:#333;border:2px solid #fff;
  }
  #health {
    height:100%;background:#0f0;width:100%;
    transition:width 0.2s linear;
  }
</style>
</head>
<body>
<div id="info">W A S D = Move | Mouse = Look | Click = Swing Sword</div>
<div id="healthbar"><div id="health"></div></div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
let scene,camera,renderer;
const keys={},monsters=[],walls=[];
let yaw=0,pitch=0;
let sword,swordSwing=0,isSwinging=false;
let playerHealth=1;
let spawnTimer=0;

init();
animate();

function init(){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x87ceeb);

  camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
  camera.position.set(0,2,8);

  const sun=new THREE.DirectionalLight(0xffffff,1);
  sun.position.set(5,10,5);
  scene.add(sun);
  scene.add(new THREE.AmbientLight(0xffffff,0.5));

  // floor
  const floor=new THREE.Mesh(
    new THREE.PlaneGeometry(300,300),
    new THREE.MeshPhongMaterial({color:0x55aa55})
  );
  floor.rotation.x=-Math.PI/2;
  scene.add(floor);

  // maze walls
  const wallGeo=new THREE.BoxGeometry(4,4,4);
  const wallMat=new THREE.MeshPhongMaterial({color:0x888888});
  for(let x=-40;x<=40;x+=8){
    for(let z=-40;z<=40;z+=8){
      if(Math.random()<0.3){
        const wall=new THREE.Mesh(wallGeo,wallMat);
        wall.position.set(x,2,z);
        scene.add(wall);
        walls.push(wall);
      }
    }
  }

  // sword
  const sGeo=new THREE.BoxGeometry(0.2,1.5,0.2);
  const sMat=new THREE.MeshPhongMaterial({color:0xccaa00});
  sword=new THREE.Mesh(sGeo,sMat);
  sword.position.set(0.5,-0.5,-1.5);
  camera.add(sword);
  scene.add(camera);

  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth,innerHeight);
  document.body.appendChild(renderer.domElement);

  document.addEventListener("keydown",e=>keys[e.code]=true);
  document.addEventListener("keyup",e=>keys[e.code]=false);

  document.addEventListener("mousemove",e=>{
    yaw-=e.movementX*0.002;
    pitch-=e.movementY*0.002;
    pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,pitch));
    camera.rotation.set(pitch,yaw,0);
  });

  document.addEventListener("click",()=>{
    if(!isSwinging){
      isSwinging=true;
      swordSwing=0;
    }
  });

  window.addEventListener("resize",()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });
}

function animate(){
  requestAnimationFrame(animate);
  movePlayer();
  moveMonsters();
  updateSword();
  updateSpawner();
  renderer.render(scene,camera);
}

function movePlayer(){
  const speed=0.3;
  const dir=new THREE.Vector3();
  if(keys["KeyW"]) dir.z-=1;
  if(keys["KeyS"]) dir.z+=1;
  if(keys["KeyA"]) dir.x-=1;
  if(keys["KeyD"]) dir.x+=1;
  dir.normalize();

  const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  const right=new THREE.Vector3(Math.sin(yaw+Math.PI/2),0,Math.cos(yaw+Math.PI/2));
  const move=new THREE.Vector3();
  move.addScaledVector(forward,dir.z*speed);
  move.addScaledVector(right,dir.x*speed);

  // tentative new position
  const newPos=camera.position.clone().add(move);
  let blocked=false;

  // check collision with walls
  for(const w of walls){
    const dx=newPos.x-w.position.x;
    const dz=newPos.z-w.position.z;
    const dist=Math.sqrt(dx*dx+dz*dz);
    if(dist<3){ // roughly wall size/2 + player radius
      blocked=true;
      break;
    }
  }

  if(!blocked) camera.position.copy(newPos);
}

function spawnMonster(){
  const mGeo=new THREE.BoxGeometry(2,2,2);
  const mMat=new THREE.MeshPhongMaterial({color:0xff0000});
  const m=new THREE.Mesh(mGeo,mMat.clone());
  m.position.set(0,1,-50 + Math.random()*10 - 5);
  m.health=3;
  m.isDead=false;
  m.fade=1;
  scene.add(m);
  monsters.push(m);
}

function updateSpawner(){
  spawnTimer += 1;
  if(spawnTimer > 120){ // every ~2 seconds
    spawnTimer=0;
    spawnMonster();
  }
}

function moveMonsters(){
  const playerPos=camera.position;
  for(let i=monsters.length-1;i>=0;i--){
    const m=monsters[i];

    if(m.isDead){
      m.fade -= 0.02;
      m.material.transparent = true;
      m.material.opacity = m.fade;
      if(m.fade<=0){
        scene.remove(m);
        monsters.splice(i,1);
      }
      continue;
    }

    const toPlayer=playerPos.clone().sub(m.position);
    const dist=toPlayer.length();

    // attack if close
    if(dist<2){
      playerHealth -= 1/16;
      updateHealthBar();
      if(playerHealth<=0){
        alert("You Died! Refresh to restart.");
        playerHealth=1;
        updateHealthBar();
      }
    }

    // sword hit
    if(dist<2 && isSwinging && swordSwing<Math.PI/3){
      m.health--;
      if(m.health>0){
        m.material.color.setHSL(0,1,m.health/3);
      }else{
        m.isDead=true;
        m.material.color.set(0x222222);
      }
    }

    // move toward player
    toPlayer.y=0;
    toPlayer.normalize();
    m.position.addScaledVector(toPlayer,0.05);
  }
}

function updateHealthBar(){
  playerHealth=Math.max(0,Math.min(1,playerHealth));
  const healthDiv=document.getElementById("health");
  healthDiv.style.width=(playerHealth*100)+"%";
  if(playerHealth>0.5) healthDiv.style.background="#0f0";
  else if(playerHealth>0.25) healthDiv.style.background="#ff0";
  else healthDiv.style.background="#f00";
}

function updateSword(){
  if(isSwinging){
    swordSwing+=0.2;
    sword.rotation.x=Math.sin(swordSwing)*Math.PI/4;
    if(swordSwing>Math.PI){
      isSwinging=false;
      sword.rotation.x=0;
    }
  }
}
</script>
</body>
</html>
